// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity ^0.8.20;

import "tnt-core/BlueprintServiceManagerBase.sol";

/**
 * @title ZkFaasBlueprint
 * @author Tangle Network
 * @notice Blueprint for Zero-Knowledge Proof Generation as a Service
 *
 * @dev This contract manages ZK guest program registration and proof generation requests.
 *
 * Architecture:
 * 1. Guest programs stored on IPFS (decentralized)
 * 2. Program metadata registered on-chain (this contract)
 * 3. Proof requests submitted as Blueprint jobs
 * 4. Operators generate proofs using SP1/RISC Zero
 * 5. Results verified and stored on-chain
 *
 * Jobs:
 * - Job 0: Register ZK Program
 * - Job 1: Generate Proof (SP1)
 * - Job 2: Generate Proof (RISC Zero)
 * - Job 3: Verify Proof On-chain
 */
contract ZkFaasBlueprint is BlueprintServiceManagerBase {
    /// @notice Program metadata stored on-chain
    struct ProgramMetadata {
        string ipfsCid;         // IPFS content identifier for ELF binary
        bytes32 elfHash;        // SHA256 hash of ELF binary for integrity
        address author;         // Program creator
        uint256 timestamp;      // Registration timestamp
        string description;     // Human-readable description
        ZkVmType zkvm;          // Which zkVM this program targets
        bool verified;          // Whether program has been verified
    }

    /// @notice Proof metadata stored on-chain
    struct ProofMetadata {
        bytes32 programHash;    // Hash of the guest program
        bytes32 inputHash;      // Hash of public inputs
        bytes32 proofHash;      // Hash of the generated proof
        address requester;      // Who requested the proof
        address operator;       // Who generated the proof
        uint256 timestamp;      // When proof was generated
        ZkVmType zkvm;          // Which zkVM was used
        bool verified;          // Whether proof has been verified on-chain
    }

    /// @notice Supported zkVM types
    enum ZkVmType {
        SP1,
        RISCZero,
        Unknown
    }

    /// @notice Mapping of program hash to metadata
    mapping(bytes32 => ProgramMetadata) public programs;

    /// @notice Mapping of proof ID to metadata
    mapping(bytes32 => ProofMetadata) public proofs;

    /// @notice Mapping of program hash to proof count
    mapping(bytes32 => uint256) public programProofCount;

    // ============================================================================
    // OPERATOR SELECTION & LOAD BALANCING
    // ============================================================================

    /// @notice Operator info for load balancing
    struct OperatorInfo {
        address addr;
        uint256 totalJobs;
        uint256 successfulJobs;
        uint256 currentLoad;
        bool active;
    }

    /// @notice Job assignment for operator selection
    struct JobAssignment {
        address assignedOperator;
        bool executed;
    }

    /// @notice Container to operator mapping (sticky routing)
    mapping(string => address) public containerOperator;

    /// @notice Operator info by address
    mapping(address => OperatorInfo) public operators;

    /// @notice Job call ID to assignment
    mapping(uint64 => JobAssignment) public jobAssignments;

    /// @notice List of all registered operators
    address[] public operatorList;

    /// @notice Events
    event ProgramRegistered(
        bytes32 indexed programHash,
        string ipfsCid,
        address indexed author,
        ZkVmType zkvm
    );

    event ProofRequested(
        bytes32 indexed proofId,
        bytes32 indexed programHash,
        address indexed requester,
        ZkVmType zkvm
    );

    event ProofGenerated(
        bytes32 indexed proofId,
        bytes32 indexed programHash,
        address indexed operator,
        bool verified
    );

    event ProofVerified(
        bytes32 indexed proofId,
        bool valid
    );

    event JobAssigned(uint64 indexed jobCallId, address indexed operator);
    event ContainerAssigned(string indexed containerId, address indexed operator);

    /// @notice Constructor
    constructor() BlueprintServiceManagerBase() {}

    /**
     * @dev Hook for service operator registration
     * @param operator The operator's details
     * @param registrationInputs Inputs required for registration (unused for now)
     */
    function onRegister(
        ServiceOperators.OperatorPreferences calldata operator,
        bytes calldata registrationInputs
    )
        external
        payable
        virtual
        override
        onlyFromMaster
    {
        // Track operator for load balancing
        address operatorAddr = operatorToAddress(operator);
        if (!operators[operatorAddr].active) {
            operatorList.push(operatorAddr);
            operators[operatorAddr] = OperatorInfo({
                addr: operatorAddr,
                totalJobs: 0,
                successfulJobs: 0,
                currentLoad: 0,
                active: true
            });
        }

        // Registration inputs are optional - emit event with empty data for now
        emit OperatorRegistered(operator, bytes32(0), "");
    }

    /**
     * @dev Hook for service instance requests
     * @param params The parameters for the service request
     *
     * Service can be requested for:
     * - Dedicated proving service
     * - Shared proving pool
     */
    function onRequest(
        ServiceOperators.RequestParams calldata params
    )
        external
        payable
        virtual
        override
        onlyFromMaster
    {
        // Service request validated by base contract
        // Additional validation can be added here

        emit ServiceRequested(params.requestId, params.requester);
    }

    // ============================================================================
    // OPERATOR SELECTION LOGIC
    // ============================================================================

    /// @notice Select operator for a job using load balancing
    /// @param jobCallId The job call ID
    /// @param containerId Optional container ID for sticky routing (empty string if not applicable)
    /// @return Selected operator address
    function selectOperator(uint64 jobCallId, string memory containerId)
        public
        returns (address)
    {
        // Check sticky routing for container-specific jobs
        if (bytes(containerId).length > 0 && containerOperator[containerId] != address(0)) {
            address stickyOp = containerOperator[containerId];
            if (operators[stickyOp].active) {
                _assignJob(jobCallId, stickyOp);
                return stickyOp;
            }
        }

        // Load balance: select operator with lowest current load
        require(operatorList.length > 0, "No operators available");

        address bestOp = operatorList[0];
        uint256 lowestLoad = operators[bestOp].currentLoad;

        for (uint256 i = 1; i < operatorList.length; i++) {
            address op = operatorList[i];
            if (!operators[op].active) continue;

            if (operators[op].currentLoad < lowestLoad) {
                lowestLoad = operators[op].currentLoad;
                bestOp = op;
            }
        }

        _assignJob(jobCallId, bestOp);
        return bestOp;
    }

    /// @notice Internal: Assign job to operator
    function _assignJob(uint64 jobCallId, address operator) internal {
        jobAssignments[jobCallId] = JobAssignment({
            assignedOperator: operator,
            executed: false
        });
        operators[operator].currentLoad += 1;
        emit JobAssigned(jobCallId, operator);
    }

    /// @notice Check if operator is assigned to job
    function isAssignedOperator(uint64 jobCallId, address operator)
        external
        view
        returns (bool)
    {
        return jobAssignments[jobCallId].assignedOperator == operator;
    }

    /**
     * @dev Hook for handling job results
     * @param serviceId The ID of the service
     * @param job The job identifier (0=Register, 1=ProveSP1, 2=ProveRISCZero, 3=Verify)
     * @param jobCallId The unique ID for the job call
     * @param operator The operator sending the result
     * @param inputs Inputs used for the job
     * @param outputs Outputs from the job execution
     */
    function onJobResult(
        uint64 serviceId,
        uint8 job,
        uint64 jobCallId,
        ServiceOperators.OperatorPreferences calldata operator,
        bytes calldata inputs,
        bytes calldata outputs
    )
        external
        payable
        virtual
        override
        onlyFromMaster
    {
        address operatorAddr = operatorToAddress(operator);

        // Validate operator assignment if job was assigned
        if (jobAssignments[jobCallId].assignedOperator != address(0)) {
            require(
                jobAssignments[jobCallId].assignedOperator == operatorAddr,
                "Operator not assigned to this job"
            );
            require(!jobAssignments[jobCallId].executed, "Job already executed");
            jobAssignments[jobCallId].executed = true;
        }

        // Update operator stats
        if (operators[operatorAddr].active) {
            operators[operatorAddr].totalJobs += 1;
            operators[operatorAddr].successfulJobs += 1;
            if (operators[operatorAddr].currentLoad > 0) {
                operators[operatorAddr].currentLoad -= 1;
            }
        }

        if (job == 0) {
            // Job 0: Register ZK Program
            _handleProgramRegistration(operator, inputs, outputs);
        } else if (job == 1) {
            // Job 1: Generate Proof (SP1)
            _handleProofGeneration(operator, inputs, outputs, ZkVmType.SP1);
        } else if (job == 2) {
            // Job 2: Generate Proof (RISC Zero)
            _handleProofGeneration(operator, inputs, outputs, ZkVmType.RISCZero);
        } else if (job == 3) {
            // Job 3: Verify Proof On-chain
            _handleProofVerification(inputs, outputs);
        } else {
            revert("Unknown job type");
        }

        emit JobResultProcessed(serviceId, job, jobCallId, operator);
    }

    /**
     * @dev Handle program registration job result
     * @param operator The operator who registered the program
     * @param inputs Job inputs (ELF binary hash, IPFS CID, description, zkVM type)
     * @param outputs Job outputs (verification status)
     */
    function _handleProgramRegistration(
        ServiceOperators.OperatorPreferences calldata operator,
        bytes calldata inputs,
        bytes calldata outputs
    ) internal {
        // Decode inputs
        (bytes32 elfHash, string memory ipfsCid, string memory description, uint8 zkvmType) =
            abi.decode(inputs, (bytes32, string, string, uint8));

        // Decode outputs (operator should have verified ELF integrity)
        (bool verified) = abi.decode(outputs, (bool));

        // Calculate program hash (deterministic identifier)
        bytes32 programHash = keccak256(abi.encodePacked(elfHash, zkvmType));

        // Ensure program doesn't already exist
        require(programs[programHash].author == address(0), "Program already registered");

        // Store program metadata
        programs[programHash] = ProgramMetadata({
            ipfsCid: ipfsCid,
            elfHash: elfHash,
            author: operatorToAddress(operator),
            timestamp: block.timestamp,
            description: description,
            zkvm: ZkVmType(zkvmType),
            verified: verified
        });

        emit ProgramRegistered(programHash, ipfsCid, operatorToAddress(operator), ZkVmType(zkvmType));
    }

    /**
     * @dev Handle proof generation job result
     * @param operator The operator who generated the proof
     * @param inputs Job inputs (program hash, public inputs)
     * @param outputs Job outputs (proof data, verification status)
     * @param zkvm The zkVM type used
     */
    function _handleProofGeneration(
        ServiceOperators.OperatorPreferences calldata operator,
        bytes calldata inputs,
        bytes calldata outputs,
        ZkVmType zkvm
    ) internal {
        // Decode inputs
        (bytes32 programHash, bytes memory publicInputs, address requester) =
            abi.decode(inputs, (bytes32, bytes, address));

        // Decode outputs
        (bytes memory proofData, bool verified) = abi.decode(outputs, (bytes, bool));

        // Ensure program exists
        require(programs[programHash].author != address(0), "Program not registered");

        // Calculate proof ID
        bytes32 inputHash = keccak256(publicInputs);
        bytes32 proofHash = keccak256(proofData);
        bytes32 proofId = keccak256(abi.encodePacked(programHash, inputHash, zkvm));

        // Store proof metadata
        proofs[proofId] = ProofMetadata({
            programHash: programHash,
            inputHash: inputHash,
            proofHash: proofHash,
            requester: requester,
            operator: operatorToAddress(operator),
            timestamp: block.timestamp,
            zkvm: zkvm,
            verified: verified
        });

        // Increment proof count for program
        programProofCount[programHash]++;

        emit ProofGenerated(proofId, programHash, operatorToAddress(operator), verified);
    }

    /**
     * @dev Handle proof verification job result
     * @param inputs Job inputs (proof ID)
     * @param outputs Job outputs (verification result)
     */
    function _handleProofVerification(
        bytes calldata inputs,
        bytes calldata outputs
    ) internal {
        // Decode inputs
        (bytes32 proofId) = abi.decode(inputs, (bytes32));

        // Decode outputs
        (bool valid) = abi.decode(outputs, (bool));

        // Ensure proof exists
        require(proofs[proofId].requester != address(0), "Proof not found");

        // Update verification status
        proofs[proofId].verified = valid;

        emit ProofVerified(proofId, valid);
    }

    /**
     * @dev Get program metadata
     * @param programHash The program hash
     * @return Program metadata
     */
    function getProgram(bytes32 programHash) external view returns (ProgramMetadata memory) {
        require(programs[programHash].author != address(0), "Program not found");
        return programs[programHash];
    }

    /**
     * @dev Get proof metadata
     * @param proofId The proof ID
     * @return Proof metadata
     */
    function getProof(bytes32 proofId) external view returns (ProofMetadata memory) {
        require(proofs[proofId].requester != address(0), "Proof not found");
        return proofs[proofId];
    }

    /**
     * @dev Convert operator preferences to address
     * @param operator The operator preferences
     * @return Operator address
     */
    function operatorToAddress(ServiceOperators.OperatorPreferences calldata operator)
        internal
        pure
        returns (address)
    {
        // Simplified: derive address from public key
        return address(uint160(uint256(keccak256(abi.encodePacked(operator.ecdsaPublicKey)))));
    }

    /// @notice Custom events
    event OperatorRegistered(
        ServiceOperators.OperatorPreferences operator,
        bytes32 publicKeyHash,
        string metadataUri
    );

    event ServiceRequested(uint64 indexed requestId, address indexed requester);

    event JobResultProcessed(
        uint64 indexed serviceId,
        uint8 indexed job,
        uint64 jobCallId,
        ServiceOperators.OperatorPreferences operator
    );
}
